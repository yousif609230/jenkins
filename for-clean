@Library('gph-neo-jenkins-library') _

pipeline {
    agent any
    parameters {
        choice(
            name: 'ENV',
            choices: ['dev', 'uat', 'prod'],
            description: 'Choose the target environment'
        )
        string(name: 'TIMEOUT', defaultValue: '15', description: 'Timeout duration', trim: true)
    }
    options {
        timeout(time: params.TIMEOUT, unit: 'MINUTES')
        buildDiscarder logRotator(numToKeepStr: '10')
    }
    environment {
        AWS_ROLE_ACCOUNT = "${AwsRoleAndAccount(params.ENV)?.ACCOUNT}"
        AWS_ROLE = "${AwsRoleAndAccount(params.ENV)?.ROLE}"
        JENKINS_CRED = credentials('jenkins-service')
        JOB_NAME = JOB_NAME.split('/').last()
        KUBECONFIG = '/etc/kubernetes/kubeconfig'

    }
    stages {
        stage('List Kubernetes Deployments') {
            steps {
                script {
                    // Authenticate with AWS and configure kubectl
                    withAWS(roleAccount: env.AWS_ROLE_ACCOUNT, role: env.AWS_ROLE) {
                    // Get all deployments across all namespaces and store in a variable
                    def deployments = sh(
                        script: "kubectl get deployments --all-namespaces -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name' --no-headers",
                        returnStdout: true
                    ).trim()
                    
                    // Parse the output and create a map of namespace to deployments
                    def deploymentMap = [:]
                    deployments.split('\n').each { line ->
                        def (namespace, deploymentName) = line.split()
                        if (!deploymentMap[namespace]) {
                            deploymentMap[namespace] = []
                        }
                        deploymentMap[namespace] << deploymentName
                    }
                    
                    // Store the deployment map for later use
                    env.DEPLOYMENT_MAP = groovy.json.JsonOutput.toJson(deploymentMap)
                    
                    // Print the found deployments in a more organized format
                    echo "==================== Kubernetes Deployments Summary ===================="
                    echo "\nTotal namespaces found: ${deploymentMap.size()}\n"
                    
                    deploymentMap.each { namespace, deps ->
                        echo "ðŸ“ Namespace: ${namespace}"
                        echo "   Total deployments: ${deps.size()}"
                        echo "   Deployments:"
                        deps.each { dep ->
                            echo "   â””â”€ ${dep}"
                        }
                        echo "----------------------------------------------------------------"
                    }
                    echo "\n================================================================"
                 }
                }
            }
        }
        stage('Select Deployment') {
            steps {
                script {
                    // Parse the deployment map back from JSON
                    def deploymentMap = readJSON text: env.DEPLOYMENT_MAP
                    
                    // Create a list of deployment choices in format "namespace/deployment"
                    def deploymentChoices = []
                    deploymentMap.each { namespace, deps ->
                        deps.each { deployment ->
                            deploymentChoices << "${namespace}/${deployment}"
                        }
                    }
                    
                    // Show input dialog with deployment choices
                    env.SELECTED_DEPLOYMENT_FULL = input(
                        message: 'Select Deployment to Restart',
                        ok: 'Select',
                        parameters: [
                            choice(
                                name: 'DEPLOYMENT_CHOICE',
                                choices: deploymentChoices,
                                description: 'Select the deployment to restart'
                            )
                        ]
                    ).trim()
                    
                    // Store the selection in environment variables for next stages
                    def parts = env.SELECTED_DEPLOYMENT_FULL.split('/')
                    env.SELECTED_NAMESPACE = parts[0]
                    env.SELECTED_DEPLOYMENT = parts[1]
                }
            }
        }
        
        stage('Verify Deployment') {
            steps {
                script {
                    // Show verification input with deployment details
                    def confirmation = input(
                        message: """
                           ====== Verify Deployment Restart ======
                           Namespace: ${env.SELECTED_NAMESPACE}
                           Deployment: ${env.SELECTED_DEPLOYMENT}
                           Environment: ${params.ENV}
                           
                           Type 'confirm' below to restart this deployment
                           =======================================
                           """,
                        parameters: [
                            string(
                                defaultValue: '',
                                name: 'CONFIRMATION',
                                description: "Type 'confirm' to restart deployment: ${env.SELECTED_DEPLOYMENT} in namespace: ${env.SELECTED_NAMESPACE}"
                            )
                        ]
                    )
                    
                    if (confirmation['CONFIRMATION'].toLowerCase() != 'confirm') {
                        error("Deployment restart cancelled: Confirmation text did not match 'confirm'")
                    }
                    
                    echo """
                    ====== Deployment Verified ======
                    Proceeding to restart:
                    Namespace: ${env.SELECTED_NAMESPACE}
                    Deployment: ${env.SELECTED_DEPLOYMENT}
                    ================================"""
                }
            }
        }
        
        stage('Restart Deployment') {
            steps {
                script {
                    echo """
                    ====== Restarting Deployment ======
                    Namespace: ${env.SELECTED_NAMESPACE}
                    Deployment: ${env.SELECTED_DEPLOYMENT}
                    ================================"""
                    
                    // Restart the deployment
                    withAWS(roleAccount: env.AWS_ROLE_ACCOUNT, role: env.AWS_ROLE) {
                        sh """
                            kubectl rollout restart deployment/${env.SELECTED_DEPLOYMENT} -n ${env.SELECTED_NAMESPACE}
                            echo "Waiting for rollout to complete..."
                            kubectl rollout status deployment/${env.SELECTED_DEPLOYMENT} -n ${env.SELECTED_NAMESPACE} --timeout=${params.TIMEOUT}m
                        """
                    }
                    
                    echo """
                    ====== Deployment Restart Complete ======
                    The deployment ${env.SELECTED_DEPLOYMENT} in namespace ${env.SELECTED_NAMESPACE} has been successfully restarted
                    ========================================"""
                }
            }
        }
    }
}
