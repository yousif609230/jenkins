@Library('gph-neo-jenkins-library') _

pipeline {
    agent any
    parameters {
        choice(
            name: 'ENV',
            choices: ['dev', 'uat', 'prod'],
            description: 'Choose the target environment'
        )
        string(name: 'TIMEOUT', defaultValue: '15', description: 'Timeout duration', trim: true)
    }
    options {
        timeout(time: params.TIMEOUT, unit: 'MINUTES')
        buildDiscarder logRotator(numToKeepStr: '10')
    }
    environment {
        AWS_ROLE_ACCOUNT = "${AwsRoleAndAccount(params.ENV)?.ACCOUNT}"
        AWS_ROLE = "${AwsRoleAndAccount(params.ENV)?.ROLE}"
        JENKINS_CRED = credentials('jenkins-service')
        JOB_NAME = JOB_NAME.split('/').last()
        KUBECONFIG = '/etc/kubernetes/kubeconfig'

    }
    stages {
        stage('List Kubernetes Deployments') {
            steps {
                script {
                    // Authenticate with AWS and configure kubectl
                    withAWS(roleAccount: env.AWS_ROLE_ACCOUNT, role: env.AWS_ROLE) {
                    // Get all deployments across all namespaces and store in a variable
                    def deployments = sh(
                        script: "kubectl get deployments --all-namespaces -o custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name' --no-headers",
                        returnStdout: true
                    ).trim()
                    
                    // Parse the output and create a map of namespace to deployments
                    def deploymentMap = [:]
                    deployments.split('\n').each { line ->
                        def (namespace, deploymentName) = line.split()
                        if (!deploymentMap[namespace]) {
                            deploymentMap[namespace] = []
                        }
                        deploymentMap[namespace] << deploymentName
                    }
                    
                    // Store the deployment map for later use
                    env.DEPLOYMENT_MAP = groovy.json.JsonOutput.toJson(deploymentMap)
                    
                    // Print the found deployments in a more organized format
                    echo "==================== Kubernetes Deployments Summary ===================="
                    echo "\nTotal namespaces found: ${deploymentMap.size()}\n"
                    
                    deploymentMap.each { namespace, deps ->
                        echo "ðŸ“ Namespace: ${namespace}"
                        echo "   Total deployments: ${deps.size()}"
                        echo "   Deployments:"
                        deps.each { dep ->
                            echo "   â””â”€ ${dep}"
                        }
                        echo "----------------------------------------------------------------"
                    }
                    echo "\n================================================================"
                 }
                }
            }
        }
        stage('Select and Restart Deployment') {
            steps {
                script {
                    // Parse the deployment map back from JSON
                    def deploymentMap = readJSON text: env.DEPLOYMENT_MAP
                    
                    // Create a list of deployment choices in format "namespace/deployment"
                    def deploymentChoices = []
                    deploymentMap.each { namespace, deps ->
                        deps.each { deployment ->
                            deploymentChoices << "${namespace}/${deployment}"
                        }
                    }
                    
                    // Show input dialog with deployment choices
                    def selectedDeployment = input(
                        message: 'Select Deployment to Restart',
                        ok: 'Restart',
                        parameters: [
                            choice(
                                name: 'DEPLOYMENT_CHOICE',
                                choices: deploymentChoices,
                                description: 'Select the deployment to restart'
                            )
                        ]
                    )
                    
                    // Split the selected value back into namespace and deployment name
                    def (namespace, deploymentName) = selectedDeployment.split('/')
                    
                    echo """
                    ====== Restarting Deployment ======
                    Namespace: ${namespace}
                    Deployment: ${deploymentName}
                    ================================"""
                    
                    // Restart the deployment
                    withAWS(roleAccount: env.AWS_ROLE_ACCOUNT, role: env.AWS_ROLE) {
                        sh """
                            kubectl rollout restart deployment/${deploymentName} -n ${namespace}
                            echo "Waiting for rollout to complete..."
                            kubectl rollout status deployment/${deploymentName} -n ${namespace} --timeout=${params.TIMEOUT}m
                        """
                    }
                    
                         echo """
                      ====== Deployment Restart Complete ======
                      The deployment ${deploymentName} in namespace ${namespace} has been successfully restarted
                      ========================================"""
                }
            }
        }
    }
}
