@Library('gph-neo-jenkins-library') _

pipeline {
    agent any
    parameters {
        choice(
            name: 'ENV',
            choices: ['dev', 'uat', 'prod'],
            description: 'Choose the target environment'
        )
        choice(name: 'HELM_CHART', choices: ['my-nginx', 'chart2', 'chart3'], description: 'Select the Helm chart')
        booleanParam(name: 'AUTOMATIC_ROLLBACK', defaultValue: false, description: 'Automatically rollback to previous revision')
        string(name: 'TIMEOUT', defaultValue: '15', description: 'Timeout duration', trim: true)
    }
    options {
        timeout(time: params.TIMEOUT, unit: 'MINUTES')
        buildDiscarder logRotator(numToKeepStr: '10')
    }
    environment {
        PROJECT_ENV = 'projects/rollback-service/env.properties'
        AWS_ROLE_ACCOUNT = "${AwsRoleAndAccount(params.ENV)?.ACCOUNT}"
        AWS_ROLE = "${AwsRoleAndAccount(params.ENV)?.ROLE}"
        JENKINS_CRED = credentials('jenkins-service')
        JOB_NAME = JOB_NAME.split('/').last()
        KUBECONFIG = '/etc/kubernetes/kubeconfig'

    }
    stages {
        stage('Load Env Variables') {
            steps {script {loadEnvVars(PROJECT_ENV)}}
        }
        stage('Validation') {
                   steps {script {ProductionValidation()}}
               }
        stage("helm history") {
            steps {
                script {
                    withAWS(roleAccount: env.AWS_ROLE_ACCOUNT, role: env.AWS_ROLE) {
                    def helmChart = params.HELM_CHART
                    sh "helm history ${helmChart}"
                    def output = sh(script: "helm history ${helmChart}", returnStdout: true).trim()
                    def revisions = output.tokenize('\n').collect { it.split()[0] }
                    if (!params.AUTOMATIC_ROLLBACK) {
                        def revision = input(
                            message: "Select the revision for ${params.HELM_CHART}",
                            parameters: [
                                choice(name: 'REVISION', choices: revisions, description: "Select the revision number ")
                            ]
                        )
                        env.CHOOSED_REVISION = revision
                    } else {
                        def lastRevision = output.tokenize('\n')[-2].split()[0]
                        env.CHOOSED_REVISION = lastRevision
                    }
                    echo "Revision That Been Choosen: ${env.CHOOSED_REVISION}"
                    }
                }
            }
        }
        stage("rollback") {
            steps {
                script {
                    sh "helm rollback ${params.HELM_CHART} ${env.CHOOSED_REVISION}"
                }
            }
        }
    }
    // post {
    //     always {
    //         script {
    //             s3LogsUploader()
    //             //sendEmailNotification("${EMAIL_TO}","${EMAIL_FROM}")
    //         }
    //     }
    // }
}

//this to be addded later after "rollback" stage , this stage will varify if all pods are ready 1/1 it will SUCESS the pipeline job 
        // stage('Verify Pods') {
        //     steps {
        //         script {
        //             def helmChart = params.HELM_CHART
        //             timeout(time: 10, unit: 'MINUTES') { // Timeout after 10 minutes
        //                 waitUntil {
        //                     def podStatus = sh(script: "kubectl get pods -l 'app.kubernetes.io/name=${helmChart}' -o jsonpath='{range .items[*]}{.metadata.name}{\" \"}{range .status.containerStatuses[*]}{.ready}{\"\\n\"}{end}{end}'", returnStdout: true).trim()
        //                     echo "Pod Status: ${podStatus}"
        //                     return !podStatus.contains("false")
        //                 }
        //             }
        //             echo "All Pods are running with status 1/1"
        //         }
        //     }
        // }
